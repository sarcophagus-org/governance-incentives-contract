import { BigNumber } from 'ethers';
import { ethers } from 'hardhat';
import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';

export const zero = ethers.constants.Zero;

export interface Reward {
  voterAddress: string;
  rewardAmount: BigNumber;
  _signer?: SignerWithAddress;
}

/**
 * @notice Sums rewards amounts that are due to voters
 * @param rewards Array of structs of voters' addresses and amounts
 * to be transfered
 */
export function getSum(rewards: Reward[]): BigNumber {
  let sum = zero;
  for (let i in rewards) {
    sum = sum.add(rewards[i].rewardAmount);
  }
  return sum;
}

/**
 * @notice Distributes a value randomly to a given array length such that
 * the sum adds back to that initial value
 * @param length array length which gets the value randomly distributed to
 * @param value value we want to distribute randomly
 */
function distributeBN(length: number, value: number): BigNumber[] {
  // internal recursive function used for math computations in number type
  // to distribute a _value randomly among _length units
  function distribute(_length: number, _value: number): number[] {
    if (_length <= 1) return [_value];
    const half = Math.floor(_length / 2);
    // dist introduces randomness to the _value imput
    const dist = Math.floor(Math.random() * _value);
    // recursively calling the function to achieve the random distribution
    let result = distribute(half, dist).concat(distribute(_length - half, _value - dist));
    return result;
  }
  // calling the distribute function on the top level function paramenters
  let distributeArray = distribute(length, value);

  // set up BN type array for top level function output
  let distributeArrayBN: BigNumber[] = [];
  // loop through each number in the array generated by the internal function and convert to BN
  for (let i = 0; i < distributeArray.length; i++) {
    let numberWei = ethers.utils.parseEther(distributeArray[i].toString());
    let BN = BigNumber.from(numberWei);
    distributeArrayBN.push(BN);
  }
  return distributeArrayBN;
}

/**
 * @notice Generates a random array of structs of voters' addresses and amounts to be claimed as rewards
 * @param numberOfVoters number of voters/signers
 * @param totalRewardAmountBN total value that will get randomly distributed to voters, such that
 * the sum adds back to total
 */
export async function randomRewards(
  numberOfVoters: number,
  totalRewardAmountBN: BigNumber
): Promise<Reward[]> {
  // initialize variables
  let signers = await ethers.getSigners();
  let totalRewardAmountNumber = +ethers.utils.formatEther(totalRewardAmountBN);
  let randomDistributionAmounts = distributeBN(numberOfVoters, totalRewardAmountNumber);
  let votersArray: Reward[] = [];

  // populate voters reward array
  for (let i = 0; i < numberOfVoters; i++) {
    let voter: Reward = {} as Reward;
    voter._signer = signers[i]; // used to sign blockchain transactions
    voter.voterAddress = signers[i].address;
    voter.rewardAmount = randomDistributionAmounts[i];
    votersArray.push(voter);
  }
  return votersArray;
}
